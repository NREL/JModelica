/*
 *    This file is part of CasADi.
 *
 *    CasADi -- A symbolic framework for dynamic optimization.
 *    Copyright (C) 2010-2014 Joel Andersson, Joris Gillis, Moritz Diehl,
 *                            K.U. Leuven. All rights reserved.
 *    Copyright (C) 2011-2014 Greg Horn
 *
 *    CasADi is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *
 *    CasADi is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with CasADi; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

/** All edits to this file will be lost - autogenerated by misc/autogencode.py */
#include "schemes_metadata.hpp"
#include <string>
namespace casadi {
std::string getSchemeName(InputOutputScheme scheme) {
  switch (scheme) {
    case SCHEME_CLEInput: return "CLEInput";
    case SCHEME_CLEOutput: return "CLEOutput";
    case SCHEME_CleStruct: return "CleStruct";
    case SCHEME_ControlledDAEInput: return "ControlledDAEInput";
    case SCHEME_ControlSimulatorInput: return "ControlSimulatorInput";
    case SCHEME_DLEInput: return "DLEInput";
    case SCHEME_DLEOutput: return "DLEOutput";
    case SCHEME_DleStruct: return "DleStruct";
    case SCHEME_DPLEInput: return "DPLEInput";
    case SCHEME_DPLEOutput: return "DPLEOutput";
    case SCHEME_DpleVecStruct: return "DpleVecStruct";
    case SCHEME_HNLPInput: return "HNLPInput";
    case SCHEME_DAEInput: return "DAEInput";
    case SCHEME_DAEOutput: return "DAEOutput";
    case SCHEME_RDAEInput: return "RDAEInput";
    case SCHEME_RDAEOutput: return "RDAEOutput";
    case SCHEME_IntegratorInput: return "IntegratorInput";
    case SCHEME_IntegratorOutput: return "IntegratorOutput";
    case SCHEME_LinsolInput: return "LinsolInput";
    case SCHEME_LinsolOutput: return "LinsolOutput";
    case SCHEME_LpSolverInput: return "LpSolverInput";
    case SCHEME_LpSolverOutput: return "LpSolverOutput";
    case SCHEME_LPStruct: return "LPStruct";
    case SCHEME_LR_DLEInput: return "LR_DLEInput";
    case SCHEME_LR_DLEOutput: return "LR_DLEOutput";
    case SCHEME_LrDleStruct: return "LrDleStruct";
    case SCHEME_LR_DPLEInput: return "LR_DPLEInput";
    case SCHEME_LR_DPLEOutput: return "LR_DPLEOutput";
    case SCHEME_LrDpleVecStruct: return "LrDpleVecStruct";
    case SCHEME_NLPInput: return "NLPInput";
    case SCHEME_NLPOutput: return "NLPOutput";
    case SCHEME_GradFInput: return "GradFInput";
    case SCHEME_GradFOutput: return "GradFOutput";
    case SCHEME_JacGInput: return "JacGInput";
    case SCHEME_JacGOutput: return "JacGOutput";
    case SCHEME_HessLagInput: return "HessLagInput";
    case SCHEME_HessLagOutput: return "HessLagOutput";
    case SCHEME_NlpSolverInput: return "NlpSolverInput";
    case SCHEME_NlpSolverOutput: return "NlpSolverOutput";
    case SCHEME_QcqpSolverInput: return "QcqpSolverInput";
    case SCHEME_QcqpSolverOutput: return "QcqpSolverOutput";
    case SCHEME_QCQPStruct: return "QCQPStruct";
    case SCHEME_QpSolverInput: return "QpSolverInput";
    case SCHEME_QpSolverOutput: return "QpSolverOutput";
    case SCHEME_QPStruct: return "QPStruct";
    case SCHEME_SDPInput: return "SDPInput";
    case SCHEME_SDPOutput: return "SDPOutput";
    case SCHEME_SDPStruct: return "SDPStruct";
    case SCHEME_SDQPInput: return "SDQPInput";
    case SCHEME_SDQPOutput: return "SDQPOutput";
    case SCHEME_SDQPStruct: return "SDQPStruct";
    case SCHEME_SOCPInput: return "SOCPInput";
    case SCHEME_SOCPOutput: return "SOCPOutput";
    case SCHEME_SOCPStruct: return "SOCPStruct";
    case SCHEME_StabilizedQpSolverInput: return "StabilizedQpSolverInput";
  default: casadi_error("getSchemeName: Scheme '" << scheme <<  "' does not exist.");
  }
}
std::string getSchemeEntryNames(InputOutputScheme scheme) {
  switch (scheme) {
    case SCHEME_CLEInput:
      return "a, v";
    case SCHEME_CLEOutput:
      return "p";
    case SCHEME_CleStruct:
      return "a, v, c";
    case SCHEME_ControlledDAEInput:
      return "t, x, z, p, u, u_interp, x_major, t0, tf";
    case SCHEME_ControlSimulatorInput:
      return "x0, p, u";
    case SCHEME_DLEInput:
      return "a, v";
    case SCHEME_DLEOutput:
      return "p";
    case SCHEME_DleStruct:
      return "a, v";
    case SCHEME_DPLEInput:
      return "a, v";
    case SCHEME_DPLEOutput:
      return "p";
    case SCHEME_DpleVecStruct:
      return "a, v";
    case SCHEME_HNLPInput:
      return "x, p, tau";
    case SCHEME_DAEInput:
      return "x, z, p, t";
    case SCHEME_DAEOutput:
      return "ode, alg, quad";
    case SCHEME_RDAEInput:
      return "rx, rz, rp, x, z, p, t";
    case SCHEME_RDAEOutput:
      return "ode, alg, quad";
    case SCHEME_IntegratorInput:
      return "x0, p, z0, rx0, rp, rz0";
    case SCHEME_IntegratorOutput:
      return "xf, qf, zf, rxf, rqf, rzf";
    case SCHEME_LinsolInput:
      return "A, B";
    case SCHEME_LinsolOutput:
      return "X";
    case SCHEME_LpSolverInput:
      return "c, a, lba, uba, lbx, ubx";
    case SCHEME_LpSolverOutput:
      return "x, cost, lam_a, lam_x";
    case SCHEME_LPStruct:
      return "a";
    case SCHEME_LR_DLEInput:
      return "a, v, c, h";
    case SCHEME_LR_DLEOutput:
      return "y";
    case SCHEME_LrDleStruct:
      return "a, v, c, h";
    case SCHEME_LR_DPLEInput:
      return "a, v, c, h";
    case SCHEME_LR_DPLEOutput:
      return "y";
    case SCHEME_LrDpleVecStruct:
      return "a, v, c, h";
    case SCHEME_NLPInput:
      return "x, p";
    case SCHEME_NLPOutput:
      return "f, g";
    case SCHEME_GradFInput:
      return "x, p";
    case SCHEME_GradFOutput:
      return "grad, f, g";
    case SCHEME_JacGInput:
      return "x, p";
    case SCHEME_JacGOutput:
      return "jac, f, g";
    case SCHEME_HessLagInput:
      return "x, p, lam_f, lam_g";
    case SCHEME_HessLagOutput:
      return "hess, f, g, grad_x, grad_p";
    case SCHEME_NlpSolverInput:
      return "x0, p, lbx, ubx, lbg, ubg, lam_x0, lam_g0";
    case SCHEME_NlpSolverOutput:
      return "x, f, g, lam_x, lam_g, lam_p";
    case SCHEME_QcqpSolverInput:
      return "h, g, p, q, r, a, lba, uba, lbx, ubx, x0, lam_x0";
    case SCHEME_QcqpSolverOutput:
      return "x, cost, lam_a, lam_x";
    case SCHEME_QCQPStruct:
      return "h, p, a";
    case SCHEME_QpSolverInput:
      return "h, g, a, lba, uba, lbx, ubx, x0, lam_x0";
    case SCHEME_QpSolverOutput:
      return "x, cost, lam_a, lam_x";
    case SCHEME_QPStruct:
      return "h, a";
    case SCHEME_SDPInput:
      return "f, c, g, a, lba, uba, lbx, ubx";
    case SCHEME_SDPOutput:
      return "x, p, dual, cost, dual_cost, lam_a, lam_x";
    case SCHEME_SDPStruct:
      return "f, g, a";
    case SCHEME_SDQPInput:
      return "h, c, f, g, a, lba, uba, lbx, ubx";
    case SCHEME_SDQPOutput:
      return "x, p, dual, cost, dual_cost, lam_a, lam_x";
    case SCHEME_SDQPStruct:
      return "h, f, g, a";
    case SCHEME_SOCPInput:
      return "g, h, e, f, c, a, lba, uba, lbx, ubx";
    case SCHEME_SOCPOutput:
      return "x, cost, lam_a, lam_x";
    case SCHEME_SOCPStruct:
      return "g, a";
    case SCHEME_StabilizedQpSolverInput:
      return "h, g, a, lba, uba, lbx, ubx, x0, lam_x0, muR, muE, mu";
  default: casadi_error("getSchemeName: Scheme '" << scheme <<  "' does not exist.");
  }
}
std::string getSchemeEntryName(InputOutputScheme scheme, int i) {
  switch (scheme) {
    case SCHEME_CLEInput:
      if (i==0) return "a";
      if (i==1) return "v";
      break;
    case SCHEME_CLEOutput:
      if (i==0) return "p";
      break;
    case SCHEME_CleStruct:
      if (i==0) return "a";
      if (i==1) return "v";
      if (i==2) return "c";
      break;
    case SCHEME_ControlledDAEInput:
      if (i==0) return "t";
      if (i==1) return "x";
      if (i==2) return "z";
      if (i==3) return "p";
      if (i==4) return "u";
      if (i==5) return "u_interp";
      if (i==6) return "x_major";
      if (i==7) return "t0";
      if (i==8) return "tf";
      break;
    case SCHEME_ControlSimulatorInput:
      if (i==0) return "x0";
      if (i==1) return "p";
      if (i==2) return "u";
      break;
    case SCHEME_DLEInput:
      if (i==0) return "a";
      if (i==1) return "v";
      break;
    case SCHEME_DLEOutput:
      if (i==0) return "p";
      break;
    case SCHEME_DleStruct:
      if (i==0) return "a";
      if (i==1) return "v";
      break;
    case SCHEME_DPLEInput:
      if (i==0) return "a";
      if (i==1) return "v";
      break;
    case SCHEME_DPLEOutput:
      if (i==0) return "p";
      break;
    case SCHEME_DpleVecStruct:
      if (i==0) return "a";
      if (i==1) return "v";
      break;
    case SCHEME_HNLPInput:
      if (i==0) return "x";
      if (i==1) return "p";
      if (i==2) return "tau";
      break;
    case SCHEME_DAEInput:
      if (i==0) return "x";
      if (i==1) return "z";
      if (i==2) return "p";
      if (i==3) return "t";
      break;
    case SCHEME_DAEOutput:
      if (i==0) return "ode";
      if (i==1) return "alg";
      if (i==2) return "quad";
      break;
    case SCHEME_RDAEInput:
      if (i==0) return "rx";
      if (i==1) return "rz";
      if (i==2) return "rp";
      if (i==3) return "x";
      if (i==4) return "z";
      if (i==5) return "p";
      if (i==6) return "t";
      break;
    case SCHEME_RDAEOutput:
      if (i==0) return "ode";
      if (i==1) return "alg";
      if (i==2) return "quad";
      break;
    case SCHEME_IntegratorInput:
      if (i==0) return "x0";
      if (i==1) return "p";
      if (i==2) return "z0";
      if (i==3) return "rx0";
      if (i==4) return "rp";
      if (i==5) return "rz0";
      break;
    case SCHEME_IntegratorOutput:
      if (i==0) return "xf";
      if (i==1) return "qf";
      if (i==2) return "zf";
      if (i==3) return "rxf";
      if (i==4) return "rqf";
      if (i==5) return "rzf";
      break;
    case SCHEME_LinsolInput:
      if (i==0) return "A";
      if (i==1) return "B";
      break;
    case SCHEME_LinsolOutput:
      if (i==0) return "X";
      break;
    case SCHEME_LpSolverInput:
      if (i==0) return "c";
      if (i==1) return "a";
      if (i==2) return "lba";
      if (i==3) return "uba";
      if (i==4) return "lbx";
      if (i==5) return "ubx";
      break;
    case SCHEME_LpSolverOutput:
      if (i==0) return "x";
      if (i==1) return "cost";
      if (i==2) return "lam_a";
      if (i==3) return "lam_x";
      break;
    case SCHEME_LPStruct:
      if (i==0) return "a";
      break;
    case SCHEME_LR_DLEInput:
      if (i==0) return "a";
      if (i==1) return "v";
      if (i==2) return "c";
      if (i==3) return "h";
      break;
    case SCHEME_LR_DLEOutput:
      if (i==0) return "y";
      break;
    case SCHEME_LrDleStruct:
      if (i==0) return "a";
      if (i==1) return "v";
      if (i==2) return "c";
      if (i==3) return "h";
      break;
    case SCHEME_LR_DPLEInput:
      if (i==0) return "a";
      if (i==1) return "v";
      if (i==2) return "c";
      if (i==3) return "h";
      break;
    case SCHEME_LR_DPLEOutput:
      if (i==0) return "y";
      break;
    case SCHEME_LrDpleVecStruct:
      if (i==0) return "a";
      if (i==1) return "v";
      if (i==2) return "c";
      if (i==3) return "h";
      break;
    case SCHEME_NLPInput:
      if (i==0) return "x";
      if (i==1) return "p";
      break;
    case SCHEME_NLPOutput:
      if (i==0) return "f";
      if (i==1) return "g";
      break;
    case SCHEME_GradFInput:
      if (i==0) return "x";
      if (i==1) return "p";
      break;
    case SCHEME_GradFOutput:
      if (i==0) return "grad";
      if (i==1) return "f";
      if (i==2) return "g";
      break;
    case SCHEME_JacGInput:
      if (i==0) return "x";
      if (i==1) return "p";
      break;
    case SCHEME_JacGOutput:
      if (i==0) return "jac";
      if (i==1) return "f";
      if (i==2) return "g";
      break;
    case SCHEME_HessLagInput:
      if (i==0) return "x";
      if (i==1) return "p";
      if (i==2) return "lam_f";
      if (i==3) return "lam_g";
      break;
    case SCHEME_HessLagOutput:
      if (i==0) return "hess";
      if (i==1) return "f";
      if (i==2) return "g";
      if (i==3) return "grad_x";
      if (i==4) return "grad_p";
      break;
    case SCHEME_NlpSolverInput:
      if (i==0) return "x0";
      if (i==1) return "p";
      if (i==2) return "lbx";
      if (i==3) return "ubx";
      if (i==4) return "lbg";
      if (i==5) return "ubg";
      if (i==6) return "lam_x0";
      if (i==7) return "lam_g0";
      break;
    case SCHEME_NlpSolverOutput:
      if (i==0) return "x";
      if (i==1) return "f";
      if (i==2) return "g";
      if (i==3) return "lam_x";
      if (i==4) return "lam_g";
      if (i==5) return "lam_p";
      break;
    case SCHEME_QcqpSolverInput:
      if (i==0) return "h";
      if (i==1) return "g";
      if (i==2) return "p";
      if (i==3) return "q";
      if (i==4) return "r";
      if (i==5) return "a";
      if (i==6) return "lba";
      if (i==7) return "uba";
      if (i==8) return "lbx";
      if (i==9) return "ubx";
      if (i==10) return "x0";
      if (i==11) return "lam_x0";
      break;
    case SCHEME_QcqpSolverOutput:
      if (i==0) return "x";
      if (i==1) return "cost";
      if (i==2) return "lam_a";
      if (i==3) return "lam_x";
      break;
    case SCHEME_QCQPStruct:
      if (i==0) return "h";
      if (i==1) return "p";
      if (i==2) return "a";
      break;
    case SCHEME_QpSolverInput:
      if (i==0) return "h";
      if (i==1) return "g";
      if (i==2) return "a";
      if (i==3) return "lba";
      if (i==4) return "uba";
      if (i==5) return "lbx";
      if (i==6) return "ubx";
      if (i==7) return "x0";
      if (i==8) return "lam_x0";
      break;
    case SCHEME_QpSolverOutput:
      if (i==0) return "x";
      if (i==1) return "cost";
      if (i==2) return "lam_a";
      if (i==3) return "lam_x";
      break;
    case SCHEME_QPStruct:
      if (i==0) return "h";
      if (i==1) return "a";
      break;
    case SCHEME_SDPInput:
      if (i==0) return "f";
      if (i==1) return "c";
      if (i==2) return "g";
      if (i==3) return "a";
      if (i==4) return "lba";
      if (i==5) return "uba";
      if (i==6) return "lbx";
      if (i==7) return "ubx";
      break;
    case SCHEME_SDPOutput:
      if (i==0) return "x";
      if (i==1) return "p";
      if (i==2) return "dual";
      if (i==3) return "cost";
      if (i==4) return "dual_cost";
      if (i==5) return "lam_a";
      if (i==6) return "lam_x";
      break;
    case SCHEME_SDPStruct:
      if (i==0) return "f";
      if (i==1) return "g";
      if (i==2) return "a";
      break;
    case SCHEME_SDQPInput:
      if (i==0) return "h";
      if (i==1) return "c";
      if (i==2) return "f";
      if (i==3) return "g";
      if (i==4) return "a";
      if (i==5) return "lba";
      if (i==6) return "uba";
      if (i==7) return "lbx";
      if (i==8) return "ubx";
      break;
    case SCHEME_SDQPOutput:
      if (i==0) return "x";
      if (i==1) return "p";
      if (i==2) return "dual";
      if (i==3) return "cost";
      if (i==4) return "dual_cost";
      if (i==5) return "lam_a";
      if (i==6) return "lam_x";
      break;
    case SCHEME_SDQPStruct:
      if (i==0) return "h";
      if (i==1) return "f";
      if (i==2) return "g";
      if (i==3) return "a";
      break;
    case SCHEME_SOCPInput:
      if (i==0) return "g";
      if (i==1) return "h";
      if (i==2) return "e";
      if (i==3) return "f";
      if (i==4) return "c";
      if (i==5) return "a";
      if (i==6) return "lba";
      if (i==7) return "uba";
      if (i==8) return "lbx";
      if (i==9) return "ubx";
      break;
    case SCHEME_SOCPOutput:
      if (i==0) return "x";
      if (i==1) return "cost";
      if (i==2) return "lam_a";
      if (i==3) return "lam_x";
      break;
    case SCHEME_SOCPStruct:
      if (i==0) return "g";
      if (i==1) return "a";
      break;
    case SCHEME_StabilizedQpSolverInput:
      if (i==0) return "h";
      if (i==1) return "g";
      if (i==2) return "a";
      if (i==3) return "lba";
      if (i==4) return "uba";
      if (i==5) return "lbx";
      if (i==6) return "ubx";
      if (i==7) return "x0";
      if (i==8) return "lam_x0";
      if (i==9) return "muR";
      if (i==10) return "muE";
      if (i==11) return "mu";
      break;
  }
  casadi_error("getSchemeEntryName: supplied number is out of range. Scheme '"
               << getSchemeName(scheme) << "' has only " << getSchemeSize(scheme)
               << " entries: " << getSchemeEntryNames(scheme) << ".");
}
std::string getSchemeEntryDoc(InputOutputScheme scheme, int i) {
  switch (scheme) {
    case SCHEME_CLEInput:
      if (i==0) return "A matrix";  // NOLINT(whitespace/line_length)
      if (i==1) return "V matrix";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_CLEOutput:
      if (i==0) return "Lyapunov matrix";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_CleStruct:
      if (i==0) return "The matrix A";  // NOLINT(whitespace/line_length)
      if (i==1) return "The matrix V";  // NOLINT(whitespace/line_length)
      if (i==2) return "The matrix C (defaults to unity)";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_ControlledDAEInput:
      if (i==0) return "Global physical time. (1-by-1)";  // NOLINT(whitespace/line_length)
      if (i==1) return "non-zeros as DAEOutput:DAE_RES";  // NOLINT(whitespace/line_length)
      if (i==2) return "Algebraic state vector (dimension np-by-1).";  // NOLINT(whitespace/line_length)
      if (i==3) return "Parameter vector (dimension np-by-1).";  // NOLINT(whitespace/line_length)
      if (i==4) return "Control vector (dimension nu-by-1).";  // NOLINT(whitespace/line_length)
      if (i==5) return "Control vector, linearly interpolated (dimension nu-by-1).";  // NOLINT(whitespace/line_length)
      if (i==6) return "State vector (dimension nx-by-1) at the last major time-step";  // NOLINT(whitespace/line_length)
      if (i==7) return "Time at start of control interval (1-by-1)";  // NOLINT(whitespace/line_length)
      if (i==8) return "Time at end of control interval (1-by-1)";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_ControlSimulatorInput:
      if (i==0) return "Differential or algebraic state at t0  (dimension nx-by-1)";  // NOLINT(whitespace/line_length)
      if (i==1) return "Parameters that are fixed over the entire horizon  (dimension np-by-1)";  // NOLINT(whitespace/line_length)
      if (i==2) return "Parameters that change over the integration intervals (dimension nu-by-(ns-1))";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_DLEInput:
      if (i==0) return "A matrix";  // NOLINT(whitespace/line_length)
      if (i==1) return "V matrix";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_DLEOutput:
      if (i==0) return "P matrix";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_DleStruct:
      if (i==0) return "The matrix A";  // NOLINT(whitespace/line_length)
      if (i==1) return "The matrix V";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_DPLEInput:
      if (i==0) return "A matrices (horzcat when const_dim, blkdiag otherwise)";  // NOLINT(whitespace/line_length)
      if (i==1) return "V matrices (horzcat when const_dim, blkdiag otherwise)";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_DPLEOutput:
      if (i==0) return "Lyapunov matrix (horzcat when const_dim, blkdiag otherwise) (Cholesky of P if pos_def)";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_DpleVecStruct:
      if (i==0) return "Sparsities for A_i, blkdiag form";  // NOLINT(whitespace/line_length)
      if (i==1) return "Sparsities for V_i, blkdiag form";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_HNLPInput:
      if (i==0) return "Decision variable";  // NOLINT(whitespace/line_length)
      if (i==1) return "Fixed parameter";  // NOLINT(whitespace/line_length)
      if (i==2) return "Homotopy parameter";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_DAEInput:
      if (i==0) return "Differential state";  // NOLINT(whitespace/line_length)
      if (i==1) return "Algebraic state";  // NOLINT(whitespace/line_length)
      if (i==2) return "Parameter";  // NOLINT(whitespace/line_length)
      if (i==3) return "Explicit time dependence";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_DAEOutput:
      if (i==0) return "Right hand side of the implicit ODE";  // NOLINT(whitespace/line_length)
      if (i==1) return "Right hand side of algebraic equations";  // NOLINT(whitespace/line_length)
      if (i==2) return "Right hand side of quadratures equations";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_RDAEInput:
      if (i==0) return "Backward differential state";  // NOLINT(whitespace/line_length)
      if (i==1) return "Backward algebraic state";  // NOLINT(whitespace/line_length)
      if (i==2) return "Backward  parameter vector";  // NOLINT(whitespace/line_length)
      if (i==3) return "Forward differential state";  // NOLINT(whitespace/line_length)
      if (i==4) return "Forward algebraic state";  // NOLINT(whitespace/line_length)
      if (i==5) return "Parameter vector";  // NOLINT(whitespace/line_length)
      if (i==6) return "Explicit time dependence";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_RDAEOutput:
      if (i==0) return "Right hand side of ODE.";  // NOLINT(whitespace/line_length)
      if (i==1) return "Right hand side of algebraic equations.";  // NOLINT(whitespace/line_length)
      if (i==2) return "Right hand side of quadratures.";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_IntegratorInput:
      if (i==0) return "Differential state at the initial time";  // NOLINT(whitespace/line_length)
      if (i==1) return "Parameters";  // NOLINT(whitespace/line_length)
      if (i==2) return "Initial guess for the algebraic variable";  // NOLINT(whitespace/line_length)
      if (i==3) return "Backward differential state at the final time";  // NOLINT(whitespace/line_length)
      if (i==4) return "Backward parameter vector";  // NOLINT(whitespace/line_length)
      if (i==5) return "Initial guess for the backwards algebraic variable";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_IntegratorOutput:
      if (i==0) return "Differential state at the final time";  // NOLINT(whitespace/line_length)
      if (i==1) return "Quadrature state at the final time";  // NOLINT(whitespace/line_length)
      if (i==2) return "Algebraic variable at the final time";  // NOLINT(whitespace/line_length)
      if (i==3) return "Backward differential state at the initial time";  // NOLINT(whitespace/line_length)
      if (i==4) return "Backward quadrature state at the initial time";  // NOLINT(whitespace/line_length)
      if (i==5) return "Backward algebraic variable at the initial time";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_LinsolInput:
      if (i==0) return "The square matrix A: sparse, (n x n).";  // NOLINT(whitespace/line_length)
      if (i==1) return "The right-hand-side matrix b: dense,  (n x m)";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_LinsolOutput:
      if (i==0) return "Solution to the linear system of equations";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_LpSolverInput:
      if (i==0) return "The vector c: dense (n x 1)";  // NOLINT(whitespace/line_length)
      if (i==1) return "The matrix A: sparse, (nc x n) - product with x must be dense.";  // NOLINT(whitespace/line_length)
      if (i==2) return "dense, (nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==3) return "dense, (nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==4) return "dense, (n x 1)";  // NOLINT(whitespace/line_length)
      if (i==5) return "dense, (n x 1)";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_LpSolverOutput:
      if (i==0) return "The primal solution";  // NOLINT(whitespace/line_length)
      if (i==1) return "The optimal cost";  // NOLINT(whitespace/line_length)
      if (i==2) return "The dual solution corresponding to linear bounds";  // NOLINT(whitespace/line_length)
      if (i==3) return "The dual solution corresponding to simple bounds";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_LPStruct:
      if (i==0) return "The matrix A: sparse";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_LR_DLEInput:
      if (i==0) return "A matrix";  // NOLINT(whitespace/line_length)
      if (i==1) return "V matrix";  // NOLINT(whitespace/line_length)
      if (i==2) return "C matrix";  // NOLINT(whitespace/line_length)
      if (i==3) return "H matrix: horizontal stack of all Hi";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_LR_DLEOutput:
      if (i==0) return "Y matrix, blkdiag form";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_LrDleStruct:
      if (i==0) return "The matrix A";  // NOLINT(whitespace/line_length)
      if (i==1) return "The matrix V";  // NOLINT(whitespace/line_length)
      if (i==2) return "The matrix C (defaults to unity)";  // NOLINT(whitespace/line_length)
      if (i==3) return "H matrix: horizontal stack of all Hi";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_LR_DPLEInput:
      if (i==0) return "A matrices (horzcat when const_dim, blkdiag otherwise)";  // NOLINT(whitespace/line_length)
      if (i==1) return "V matrices (horzcat when const_dim, blkdiag otherwise)";  // NOLINT(whitespace/line_length)
      if (i==2) return "C matrix";  // NOLINT(whitespace/line_length)
      if (i==3) return "H matrix: horizontal stack of all Hi";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_LR_DPLEOutput:
      if (i==0) return "Lyapunov matrix (horzcat when const_dim, blkdiag otherwise) (Cholesky of P if pos_def)";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_LrDpleVecStruct:
      if (i==0) return "Sparsities for A_i, blkdiag form";  // NOLINT(whitespace/line_length)
      if (i==1) return "Sparsities for V_i, blkdiag form";  // NOLINT(whitespace/line_length)
      if (i==2) return "Sparsities for C_i (defaults to unity), blkdiag form";  // NOLINT(whitespace/line_length)
      if (i==3) return "Sparsities for H_i (defaults to unity), blkdiag form";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_NLPInput:
      if (i==0) return "Decision variable";  // NOLINT(whitespace/line_length)
      if (i==1) return "Fixed parameter";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_NLPOutput:
      if (i==0) return "Objective function";  // NOLINT(whitespace/line_length)
      if (i==1) return "Constraint function";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_GradFInput:
      if (i==0) return "Decision variable";  // NOLINT(whitespace/line_length)
      if (i==1) return "Fixed parameter";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_GradFOutput:
      if (i==0) return "Jacobian of the constraints";  // NOLINT(whitespace/line_length)
      if (i==1) return "Objective function";  // NOLINT(whitespace/line_length)
      if (i==2) return "Constraint function";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_JacGInput:
      if (i==0) return "Decision variable";  // NOLINT(whitespace/line_length)
      if (i==1) return "Fixed parameter";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_JacGOutput:
      if (i==0) return "Jacobian of the constraints";  // NOLINT(whitespace/line_length)
      if (i==1) return "Objective function";  // NOLINT(whitespace/line_length)
      if (i==2) return "Constraint function";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_HessLagInput:
      if (i==0) return "Decision variable";  // NOLINT(whitespace/line_length)
      if (i==1) return "Fixed parameter";  // NOLINT(whitespace/line_length)
      if (i==2) return "NLP solver might use to scale the objective.";  // NOLINT(whitespace/line_length)
      if (i==3) return "Multiplier for g";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_HessLagOutput:
      if (i==0) return "Hessian of the Lagrangian";  // NOLINT(whitespace/line_length)
      if (i==1) return "Objective function";  // NOLINT(whitespace/line_length)
      if (i==2) return "Constraint function";  // NOLINT(whitespace/line_length)
      if (i==3) return "Gradient of the Lagrangian with respect to x";  // NOLINT(whitespace/line_length)
      if (i==4) return "Gradient of the Lagrangian with respect to p";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_NlpSolverInput:
      if (i==0) return "Decision variables, initial guess (nx x 1) ";  // NOLINT(whitespace/line_length)
      if (i==1) return "Value of fixed parameters (np x 1)";  // NOLINT(whitespace/line_length)
      if (i==2) return "Decision variables lower bound (nx x 1), default -inf";  // NOLINT(whitespace/line_length)
      if (i==3) return "Decision variables upper bound (nx x 1), default +inf";  // NOLINT(whitespace/line_length)
      if (i==4) return "Constraints lower bound (ng x 1), default -inf";  // NOLINT(whitespace/line_length)
      if (i==5) return "Constraints upper bound (ng x 1), default +inf";  // NOLINT(whitespace/line_length)
      if (i==6) return "Lagrange multipliers for bounds on X, initial guess (nx x 1)";  // NOLINT(whitespace/line_length)
      if (i==7) return "Lagrange multipliers for bounds on G, initial guess (ng x 1)";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_NlpSolverOutput:
      if (i==0) return "Decision variables at the optimal solution (nx x 1)";  // NOLINT(whitespace/line_length)
      if (i==1) return "Cost function value at the optimal solution (1 x 1)";  // NOLINT(whitespace/line_length)
      if (i==2) return "Constraints function at the optimal solution (ng x 1)";  // NOLINT(whitespace/line_length)
      if (i==3) return "Lagrange multipliers for bounds on X at the solution (nx x 1)";  // NOLINT(whitespace/line_length)
      if (i==4) return "Lagrange multipliers for bounds on G at the solution (ng x 1)";  // NOLINT(whitespace/line_length)
      if (i==5) return "Lagrange multipliers for bounds on P at the solution (np x 1)";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_QcqpSolverInput:
      if (i==0) return "The matrix is assumed to be symmetrical.";  // NOLINT(whitespace/line_length)
      if (i==1) return "The vector g: dense,  (n x 1)";  // NOLINT(whitespace/line_length)
      if (i==2) return "triangular part is actually used. The matrix is assumed to be symmetrical.";  // NOLINT(whitespace/line_length)
      if (i==3) return "The vertical stack of all qi: dense,  (nq n x 1)";  // NOLINT(whitespace/line_length)
      if (i==4) return "The vertical stack of all scalars ri (nq x 1) ";  // NOLINT(whitespace/line_length)
      if (i==5) return "The matrix A: sparse, (nc x n) - product with x must be dense.";  // NOLINT(whitespace/line_length)
      if (i==6) return "dense, (nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==7) return "dense, (nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==8) return "dense, (n x 1)";  // NOLINT(whitespace/line_length)
      if (i==9) return "dense, (n x 1)";  // NOLINT(whitespace/line_length)
      if (i==10) return "dense, (n x 1)";  // NOLINT(whitespace/line_length)
      if (i==11) return "dense";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_QcqpSolverOutput:
      if (i==0) return "The primal solution";  // NOLINT(whitespace/line_length)
      if (i==1) return "The optimal cost";  // NOLINT(whitespace/line_length)
      if (i==2) return "The dual solution corresponding to linear bounds";  // NOLINT(whitespace/line_length)
      if (i==3) return "The dual solution corresponding to simple bounds";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_QCQPStruct:
      if (i==0) return "The matrix is assumed to be symmetrical.";  // NOLINT(whitespace/line_length)
      if (i==1) return "triangular part is actually used. The matrix is assumed to be symmetrical.";  // NOLINT(whitespace/line_length)
      if (i==2) return "The matrix A: sparse, (nc x n) - product with x must be dense.";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_QpSolverInput:
      if (i==0) return "The matrix is assumed to be symmetrical.";  // NOLINT(whitespace/line_length)
      if (i==1) return "The vector g: dense,  (n x 1)";  // NOLINT(whitespace/line_length)
      if (i==2) return "The matrix A: sparse, (nc x n) - product with x must be dense.";  // NOLINT(whitespace/line_length)
      if (i==3) return "dense, (nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==4) return "dense, (nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==5) return "dense, (n x 1)";  // NOLINT(whitespace/line_length)
      if (i==6) return "dense, (n x 1)";  // NOLINT(whitespace/line_length)
      if (i==7) return "dense, (n x 1)";  // NOLINT(whitespace/line_length)
      if (i==8) return "dense";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_QpSolverOutput:
      if (i==0) return "The primal solution";  // NOLINT(whitespace/line_length)
      if (i==1) return "The optimal cost";  // NOLINT(whitespace/line_length)
      if (i==2) return "The dual solution corresponding to linear bounds";  // NOLINT(whitespace/line_length)
      if (i==3) return "The dual solution corresponding to simple bounds";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_QPStruct:
      if (i==0) return "The matrix is assumed to be symmetrical.";  // NOLINT(whitespace/line_length)
      if (i==1) return "The matrix A: sparse, (nc x n) - product with x must be dense.";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_SDPInput:
      if (i==0) return "The horizontal stack of all matrices F_i: ( m x nm)";  // NOLINT(whitespace/line_length)
      if (i==1) return "The vector c: ( n x 1)";  // NOLINT(whitespace/line_length)
      if (i==2) return "The matrix G: ( m x m)";  // NOLINT(whitespace/line_length)
      if (i==3) return "The matrix A: ( nc x n)";  // NOLINT(whitespace/line_length)
      if (i==4) return "Lower bounds on Ax ( nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==5) return "Upper bounds on Ax  ( nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==6) return "Lower bounds on x ( n x 1 )";  // NOLINT(whitespace/line_length)
      if (i==7) return "Upper bounds on x ( n x 1 )";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_SDPOutput:
      if (i==0) return "The primal solution (n x 1) - may be used as initial guess";  // NOLINT(whitespace/line_length)
      if (i==1) return "The solution P (m x m) - may be used as initial guess";  // NOLINT(whitespace/line_length)
      if (i==2) return "The dual solution (m x m) - may be used as initial guess";  // NOLINT(whitespace/line_length)
      if (i==3) return "The primal optimal cost (1 x 1)";  // NOLINT(whitespace/line_length)
      if (i==4) return "The dual optimal cost (1 x 1)";  // NOLINT(whitespace/line_length)
      if (i==5) return "The dual solution corresponding to the linear constraints  (nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==6) return "The dual solution corresponding to simple bounds  (n x 1)";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_SDPStruct:
      if (i==0) return "The horizontal stack of all matrices F_i: ( m x nm)";  // NOLINT(whitespace/line_length)
      if (i==1) return "The matrix G: ( m x m)";  // NOLINT(whitespace/line_length)
      if (i==2) return "The matrix A: ( nc x n)";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_SDQPInput:
      if (i==0) return "The matrix H: sparse ( n x n)";  // NOLINT(whitespace/line_length)
      if (i==1) return "The vector c: ( n x 1)";  // NOLINT(whitespace/line_length)
      if (i==2) return "The horizontal stack of all matrices F_i: ( m x nm)";  // NOLINT(whitespace/line_length)
      if (i==3) return "The matrix G: ( m x m)";  // NOLINT(whitespace/line_length)
      if (i==4) return "The matrix A: ( nc x n)";  // NOLINT(whitespace/line_length)
      if (i==5) return "Lower bounds on Ax ( nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==6) return "Upper bounds on Ax  ( nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==7) return "Lower bounds on x ( n x 1 )";  // NOLINT(whitespace/line_length)
      if (i==8) return "Upper bounds on x ( n x 1 )";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_SDQPOutput:
      if (i==0) return "The primal solution (n x 1) - may be used as initial guess";  // NOLINT(whitespace/line_length)
      if (i==1) return "The solution P (m x m) - may be used as initial guess";  // NOLINT(whitespace/line_length)
      if (i==2) return "The dual solution (m x m) - may be used as initial guess";  // NOLINT(whitespace/line_length)
      if (i==3) return "The primal optimal cost (1 x 1)";  // NOLINT(whitespace/line_length)
      if (i==4) return "The dual optimal cost (1 x 1)";  // NOLINT(whitespace/line_length)
      if (i==5) return "The dual solution corresponding to the linear constraints  (nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==6) return "The dual solution corresponding to simple bounds  (n x 1)";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_SDQPStruct:
      if (i==0) return "The matrix H: sparse ( n x n)";  // NOLINT(whitespace/line_length)
      if (i==1) return "The horizontal stack of all matrices F_i: ( m x nm)";  // NOLINT(whitespace/line_length)
      if (i==2) return "The matrix G: ( m x m)";  // NOLINT(whitespace/line_length)
      if (i==3) return "The matrix A: ( nc x n)";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_SOCPInput:
      if (i==0) return "The horizontal stack of all matrices Gi: ( n x N)";  // NOLINT(whitespace/line_length)
      if (i==1) return "The vertical stack of all vectors hi: ( N x 1)";  // NOLINT(whitespace/line_length)
      if (i==2) return "The vertical stack of all vectors ei: ( nm x 1)";  // NOLINT(whitespace/line_length)
      if (i==3) return "The vertical stack of all scalars fi: ( m x 1)";  // NOLINT(whitespace/line_length)
      if (i==4) return "The vector c: ( n x 1)";  // NOLINT(whitespace/line_length)
      if (i==5) return "The matrix A: ( nc x n)";  // NOLINT(whitespace/line_length)
      if (i==6) return "Lower bounds on Ax ( nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==7) return "Upper bounds on Ax  ( nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==8) return "Lower bounds on x ( n x 1 )";  // NOLINT(whitespace/line_length)
      if (i==9) return "Upper bounds on x ( n x 1 )";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_SOCPOutput:
      if (i==0) return "The primal solution (n x 1)";  // NOLINT(whitespace/line_length)
      if (i==1) return "The primal optimal cost (1 x 1)";  // NOLINT(whitespace/line_length)
      if (i==2) return "The dual solution corresponding to the linear constraints  (nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==3) return "The dual solution corresponding to simple bounds  (n x 1)";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_SOCPStruct:
      if (i==0) return "The horizontal stack of all matrices Gi: ( n x N)";  // NOLINT(whitespace/line_length)
      if (i==1) return "The matrix A: ( nc x n)";  // NOLINT(whitespace/line_length)
      break;
    case SCHEME_StabilizedQpSolverInput:
      if (i==0) return "The matrix is assumed to be symmetrical.";  // NOLINT(whitespace/line_length)
      if (i==1) return "The vector g: dense,  (n x 1)";  // NOLINT(whitespace/line_length)
      if (i==2) return "The matrix A: sparse, (nc x n) - product with x must be dense.";  // NOLINT(whitespace/line_length)
      if (i==3) return "dense, (nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==4) return "dense, (nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==5) return "dense, (n x 1)";  // NOLINT(whitespace/line_length)
      if (i==6) return "dense, (n x 1)";  // NOLINT(whitespace/line_length)
      if (i==7) return "dense, (n x 1)";  // NOLINT(whitespace/line_length)
      if (i==8) return "dense";  // NOLINT(whitespace/line_length)
      if (i==9) return "dense (1 x 1)";  // NOLINT(whitespace/line_length)
      if (i==10) return "dense (nc x 1)";  // NOLINT(whitespace/line_length)
      if (i==11) return "dense (nc x 1)";  // NOLINT(whitespace/line_length)
      break;
  }
  casadi_error("getSchemeEntryDoc: supplied number is out of range. Scheme '"
               << getSchemeName(scheme) << "' has only " << getSchemeSize(scheme)
               << " entries: " << getSchemeEntryNames(scheme) << ".");
}
std::string getSchemeEntryEnumName(InputOutputScheme scheme, int i) {
  switch (scheme) {
    case SCHEME_CLEInput:
      if (i==0) return "CLE_A";
      if (i==1) return "CLE_V";
      break;
    case SCHEME_CLEOutput:
      if (i==0) return "CLE_P";
      break;
    case SCHEME_CleStruct:
      if (i==0) return "Cle_STRUCT_A";
      if (i==1) return "Cle_STRUCT_V";
      if (i==2) return "Cle_STRUCT_C";
      break;
    case SCHEME_ControlledDAEInput:
      if (i==0) return "CONTROL_DAE_T";
      if (i==1) return "CONTROL_DAE_X";
      if (i==2) return "CONTROL_DAE_Z";
      if (i==3) return "CONTROL_DAE_P";
      if (i==4) return "CONTROL_DAE_U";
      if (i==5) return "CONTROL_DAE_U_INTERP";
      if (i==6) return "CONTROL_DAE_X_MAJOR";
      if (i==7) return "CONTROL_DAE_T0";
      if (i==8) return "CONTROL_DAE_TF";
      break;
    case SCHEME_ControlSimulatorInput:
      if (i==0) return "CONTROLSIMULATOR_X0";
      if (i==1) return "CONTROLSIMULATOR_P";
      if (i==2) return "CONTROLSIMULATOR_U";
      break;
    case SCHEME_DLEInput:
      if (i==0) return "DLE_A";
      if (i==1) return "DLE_V";
      break;
    case SCHEME_DLEOutput:
      if (i==0) return "DLE_P";
      break;
    case SCHEME_DleStruct:
      if (i==0) return "Dle_STRUCT_A";
      if (i==1) return "Dle_STRUCT_V";
      break;
    case SCHEME_DPLEInput:
      if (i==0) return "DPLE_A";
      if (i==1) return "DPLE_V";
      break;
    case SCHEME_DPLEOutput:
      if (i==0) return "DPLE_P";
      break;
    case SCHEME_DpleVecStruct:
      if (i==0) return "Dple_STRUCT_A";
      if (i==1) return "Dple_STRUCT_V";
      break;
    case SCHEME_HNLPInput:
      if (i==0) return "HNL_X";
      if (i==1) return "HNL_P";
      if (i==2) return "HNL_TAU";
      break;
    case SCHEME_DAEInput:
      if (i==0) return "DAE_X";
      if (i==1) return "DAE_Z";
      if (i==2) return "DAE_P";
      if (i==3) return "DAE_T";
      break;
    case SCHEME_DAEOutput:
      if (i==0) return "DAE_ODE";
      if (i==1) return "DAE_ALG";
      if (i==2) return "DAE_QUAD";
      break;
    case SCHEME_RDAEInput:
      if (i==0) return "RDAE_RX";
      if (i==1) return "RDAE_RZ";
      if (i==2) return "RDAE_RP";
      if (i==3) return "RDAE_X";
      if (i==4) return "RDAE_Z";
      if (i==5) return "RDAE_P";
      if (i==6) return "RDAE_T";
      break;
    case SCHEME_RDAEOutput:
      if (i==0) return "RDAE_ODE";
      if (i==1) return "RDAE_ALG";
      if (i==2) return "RDAE_QUAD";
      break;
    case SCHEME_IntegratorInput:
      if (i==0) return "INTEGRATOR_X0";
      if (i==1) return "INTEGRATOR_P";
      if (i==2) return "INTEGRATOR_Z0";
      if (i==3) return "INTEGRATOR_RX0";
      if (i==4) return "INTEGRATOR_RP";
      if (i==5) return "INTEGRATOR_RZ0";
      break;
    case SCHEME_IntegratorOutput:
      if (i==0) return "INTEGRATOR_XF";
      if (i==1) return "INTEGRATOR_QF";
      if (i==2) return "INTEGRATOR_ZF";
      if (i==3) return "INTEGRATOR_RXF";
      if (i==4) return "INTEGRATOR_RQF";
      if (i==5) return "INTEGRATOR_RZF";
      break;
    case SCHEME_LinsolInput:
      if (i==0) return "LINSOL_A";
      if (i==1) return "LINSOL_B";
      break;
    case SCHEME_LinsolOutput:
      if (i==0) return "LINSOL_X";
      break;
    case SCHEME_LpSolverInput:
      if (i==0) return "LP_SOLVER_C";
      if (i==1) return "LP_SOLVER_A";
      if (i==2) return "LP_SOLVER_LBA";
      if (i==3) return "LP_SOLVER_UBA";
      if (i==4) return "LP_SOLVER_LBX";
      if (i==5) return "LP_SOLVER_UBX";
      break;
    case SCHEME_LpSolverOutput:
      if (i==0) return "LP_SOLVER_X";
      if (i==1) return "LP_SOLVER_COST";
      if (i==2) return "LP_SOLVER_LAM_A";
      if (i==3) return "LP_SOLVER_LAM_X";
      break;
    case SCHEME_LPStruct:
      if (i==0) return "LP_STRUCT_A";
      break;
    case SCHEME_LR_DLEInput:
      if (i==0) return "LR_DLE_A";
      if (i==1) return "LR_DLE_V";
      if (i==2) return "LR_DLE_C";
      if (i==3) return "LR_DLE_H";
      break;
    case SCHEME_LR_DLEOutput:
      if (i==0) return "LR_DLE_Y";
      break;
    case SCHEME_LrDleStruct:
      if (i==0) return "LR_DLE_STRUCT_A";
      if (i==1) return "LR_DLE_STRUCT_V";
      if (i==2) return "LR_DLE_STRUCT_C";
      if (i==3) return "LR_DLE_STRUCT_H";
      break;
    case SCHEME_LR_DPLEInput:
      if (i==0) return "LR_DPLE_A";
      if (i==1) return "LR_DPLE_V";
      if (i==2) return "LR_DPLE_C";
      if (i==3) return "LR_DPLE_H";
      break;
    case SCHEME_LR_DPLEOutput:
      if (i==0) return "LR_DPLE_Y";
      break;
    case SCHEME_LrDpleVecStruct:
      if (i==0) return "LR_Dple_STRUCT_A";
      if (i==1) return "LR_Dple_STRUCT_V";
      if (i==2) return "LR_Dple_STRUCT_C";
      if (i==3) return "LR_Dple_STRUCT_H";
      break;
    case SCHEME_NLPInput:
      if (i==0) return "NL_X";
      if (i==1) return "NL_P";
      break;
    case SCHEME_NLPOutput:
      if (i==0) return "NL_F";
      if (i==1) return "NL_G";
      break;
    case SCHEME_GradFInput:
      if (i==0) return "GRADF_X";
      if (i==1) return "GRADF_P";
      break;
    case SCHEME_GradFOutput:
      if (i==0) return "GRADF_GRAD";
      if (i==1) return "GRADF_F";
      if (i==2) return "GRADF_G";
      break;
    case SCHEME_JacGInput:
      if (i==0) return "JACG_X";
      if (i==1) return "JACG_P";
      break;
    case SCHEME_JacGOutput:
      if (i==0) return "JACG_JAC";
      if (i==1) return "JACG_F";
      if (i==2) return "JACG_G";
      break;
    case SCHEME_HessLagInput:
      if (i==0) return "HESSLAG_X";
      if (i==1) return "HESSLAG_P";
      if (i==2) return "HESSLAG_LAM_F";
      if (i==3) return "HESSLAG_LAM_G";
      break;
    case SCHEME_HessLagOutput:
      if (i==0) return "HESSLAG_HESS";
      if (i==1) return "HESSLAG_F";
      if (i==2) return "HESSLAG_G";
      if (i==3) return "HESSLAG_GRAD_X";
      if (i==4) return "HESSLAG_GRAD_P";
      break;
    case SCHEME_NlpSolverInput:
      if (i==0) return "NLP_SOLVER_X0";
      if (i==1) return "NLP_SOLVER_P";
      if (i==2) return "NLP_SOLVER_LBX";
      if (i==3) return "NLP_SOLVER_UBX";
      if (i==4) return "NLP_SOLVER_LBG";
      if (i==5) return "NLP_SOLVER_UBG";
      if (i==6) return "NLP_SOLVER_LAM_X0";
      if (i==7) return "NLP_SOLVER_LAM_G0";
      break;
    case SCHEME_NlpSolverOutput:
      if (i==0) return "NLP_SOLVER_X";
      if (i==1) return "NLP_SOLVER_F";
      if (i==2) return "NLP_SOLVER_G";
      if (i==3) return "NLP_SOLVER_LAM_X";
      if (i==4) return "NLP_SOLVER_LAM_G";
      if (i==5) return "NLP_SOLVER_LAM_P";
      break;
    case SCHEME_QcqpSolverInput:
      if (i==0) return "QCQP_SOLVER_H";
      if (i==1) return "QCQP_SOLVER_G";
      if (i==2) return "QCQP_SOLVER_P";
      if (i==3) return "QCQP_SOLVER_Q";
      if (i==4) return "QCQP_SOLVER_R";
      if (i==5) return "QCQP_SOLVER_A";
      if (i==6) return "QCQP_SOLVER_LBA";
      if (i==7) return "QCQP_SOLVER_UBA";
      if (i==8) return "QCQP_SOLVER_LBX";
      if (i==9) return "QCQP_SOLVER_UBX";
      if (i==10) return "QCQP_SOLVER_X0";
      if (i==11) return "QCQP_SOLVER_LAM_X0";
      break;
    case SCHEME_QcqpSolverOutput:
      if (i==0) return "QCQP_SOLVER_X";
      if (i==1) return "QCQP_SOLVER_COST";
      if (i==2) return "QCQP_SOLVER_LAM_A";
      if (i==3) return "QCQP_SOLVER_LAM_X";
      break;
    case SCHEME_QCQPStruct:
      if (i==0) return "QCQP_STRUCT_H";
      if (i==1) return "QCQP_STRUCT_P";
      if (i==2) return "QCQP_STRUCT_A";
      break;
    case SCHEME_QpSolverInput:
      if (i==0) return "QP_SOLVER_H";
      if (i==1) return "QP_SOLVER_G";
      if (i==2) return "QP_SOLVER_A";
      if (i==3) return "QP_SOLVER_LBA";
      if (i==4) return "QP_SOLVER_UBA";
      if (i==5) return "QP_SOLVER_LBX";
      if (i==6) return "QP_SOLVER_UBX";
      if (i==7) return "QP_SOLVER_X0";
      if (i==8) return "QP_SOLVER_LAM_X0";
      break;
    case SCHEME_QpSolverOutput:
      if (i==0) return "QP_SOLVER_X";
      if (i==1) return "QP_SOLVER_COST";
      if (i==2) return "QP_SOLVER_LAM_A";
      if (i==3) return "QP_SOLVER_LAM_X";
      break;
    case SCHEME_QPStruct:
      if (i==0) return "QP_STRUCT_H";
      if (i==1) return "QP_STRUCT_A";
      break;
    case SCHEME_SDPInput:
      if (i==0) return "SDP_SOLVER_F";
      if (i==1) return "SDP_SOLVER_C";
      if (i==2) return "SDP_SOLVER_G";
      if (i==3) return "SDP_SOLVER_A";
      if (i==4) return "SDP_SOLVER_LBA";
      if (i==5) return "SDP_SOLVER_UBA";
      if (i==6) return "SDP_SOLVER_LBX";
      if (i==7) return "SDP_SOLVER_UBX";
      break;
    case SCHEME_SDPOutput:
      if (i==0) return "SDP_SOLVER_X";
      if (i==1) return "SDP_SOLVER_P";
      if (i==2) return "SDP_SOLVER_DUAL";
      if (i==3) return "SDP_SOLVER_COST";
      if (i==4) return "SDP_SOLVER_DUAL_COST";
      if (i==5) return "SDP_SOLVER_LAM_A";
      if (i==6) return "SDP_SOLVER_LAM_X";
      break;
    case SCHEME_SDPStruct:
      if (i==0) return "SDP_STRUCT_F";
      if (i==1) return "SDP_STRUCT_G";
      if (i==2) return "SDP_STRUCT_A";
      break;
    case SCHEME_SDQPInput:
      if (i==0) return "SDQP_SOLVER_H";
      if (i==1) return "SDQP_SOLVER_C";
      if (i==2) return "SDQP_SOLVER_F";
      if (i==3) return "SDQP_SOLVER_G";
      if (i==4) return "SDQP_SOLVER_A";
      if (i==5) return "SDQP_SOLVER_LBA";
      if (i==6) return "SDQP_SOLVER_UBA";
      if (i==7) return "SDQP_SOLVER_LBX";
      if (i==8) return "SDQP_SOLVER_UBX";
      break;
    case SCHEME_SDQPOutput:
      if (i==0) return "SDQP_SOLVER_X";
      if (i==1) return "SDQP_SOLVER_P";
      if (i==2) return "SDQP_SOLVER_DUAL";
      if (i==3) return "SDQP_SOLVER_COST";
      if (i==4) return "SDQP_SOLVER_DUAL_COST";
      if (i==5) return "SDQP_SOLVER_LAM_A";
      if (i==6) return "SDQP_SOLVER_LAM_X";
      break;
    case SCHEME_SDQPStruct:
      if (i==0) return "SDQP_STRUCT_H";
      if (i==1) return "SDQP_STRUCT_F";
      if (i==2) return "SDQP_STRUCT_G";
      if (i==3) return "SDQP_STRUCT_A";
      break;
    case SCHEME_SOCPInput:
      if (i==0) return "SOCP_SOLVER_G";
      if (i==1) return "SOCP_SOLVER_H";
      if (i==2) return "SOCP_SOLVER_E";
      if (i==3) return "SOCP_SOLVER_F";
      if (i==4) return "SOCP_SOLVER_C";
      if (i==5) return "SOCP_SOLVER_A";
      if (i==6) return "SOCP_SOLVER_LBA";
      if (i==7) return "SOCP_SOLVER_UBA";
      if (i==8) return "SOCP_SOLVER_LBX";
      if (i==9) return "SOCP_SOLVER_UBX";
      break;
    case SCHEME_SOCPOutput:
      if (i==0) return "SOCP_SOLVER_X";
      if (i==1) return "SOCP_SOLVER_COST";
      if (i==2) return "SOCP_SOLVER_LAM_A";
      if (i==3) return "SOCP_SOLVER_LAM_X";
      break;
    case SCHEME_SOCPStruct:
      if (i==0) return "SOCP_STRUCT_G";
      if (i==1) return "SOCP_STRUCT_A";
      break;
    case SCHEME_StabilizedQpSolverInput:
      if (i==0) return "STABILIZED_QP_SOLVER_H";
      if (i==1) return "STABILIZED_QP_SOLVER_G";
      if (i==2) return "STABILIZED_QP_SOLVER_A";
      if (i==3) return "STABILIZED_QP_SOLVER_LBA";
      if (i==4) return "STABILIZED_QP_SOLVER_UBA";
      if (i==5) return "STABILIZED_QP_SOLVER_LBX";
      if (i==6) return "STABILIZED_QP_SOLVER_UBX";
      if (i==7) return "STABILIZED_QP_SOLVER_X0";
      if (i==8) return "STABILIZED_QP_SOLVER_LAM_X0";
      if (i==9) return "STABILIZED_QP_SOLVER_MUR";
      if (i==10) return "STABILIZED_QP_SOLVER_MUE";
      if (i==11) return "STABILIZED_QP_SOLVER_MU";
      break;
  }
  casadi_error("getSchemeEntryEnumName: supplied number is out of range. Scheme '"
               << getSchemeName(scheme) << "' has only "
               << getSchemeSize(scheme) << " entries: "
                << getSchemeEntryNames(scheme) << ".");
}
int getSchemeSize(InputOutputScheme scheme) {
  switch (scheme) {
    case SCHEME_CLEInput:
      return 2;
      break;
    case SCHEME_CLEOutput:
      return 1;
      break;
    case SCHEME_CleStruct:
      return 3;
      break;
    case SCHEME_ControlledDAEInput:
      return 9;
      break;
    case SCHEME_ControlSimulatorInput:
      return 3;
      break;
    case SCHEME_DLEInput:
      return 2;
      break;
    case SCHEME_DLEOutput:
      return 1;
      break;
    case SCHEME_DleStruct:
      return 2;
      break;
    case SCHEME_DPLEInput:
      return 2;
      break;
    case SCHEME_DPLEOutput:
      return 1;
      break;
    case SCHEME_DpleVecStruct:
      return 2;
      break;
    case SCHEME_HNLPInput:
      return 3;
      break;
    case SCHEME_DAEInput:
      return 4;
      break;
    case SCHEME_DAEOutput:
      return 3;
      break;
    case SCHEME_RDAEInput:
      return 7;
      break;
    case SCHEME_RDAEOutput:
      return 3;
      break;
    case SCHEME_IntegratorInput:
      return 6;
      break;
    case SCHEME_IntegratorOutput:
      return 6;
      break;
    case SCHEME_LinsolInput:
      return 2;
      break;
    case SCHEME_LinsolOutput:
      return 1;
      break;
    case SCHEME_LpSolverInput:
      return 6;
      break;
    case SCHEME_LpSolverOutput:
      return 4;
      break;
    case SCHEME_LPStruct:
      return 1;
      break;
    case SCHEME_LR_DLEInput:
      return 4;
      break;
    case SCHEME_LR_DLEOutput:
      return 1;
      break;
    case SCHEME_LrDleStruct:
      return 4;
      break;
    case SCHEME_LR_DPLEInput:
      return 4;
      break;
    case SCHEME_LR_DPLEOutput:
      return 1;
      break;
    case SCHEME_LrDpleVecStruct:
      return 4;
      break;
    case SCHEME_NLPInput:
      return 2;
      break;
    case SCHEME_NLPOutput:
      return 2;
      break;
    case SCHEME_GradFInput:
      return 2;
      break;
    case SCHEME_GradFOutput:
      return 3;
      break;
    case SCHEME_JacGInput:
      return 2;
      break;
    case SCHEME_JacGOutput:
      return 3;
      break;
    case SCHEME_HessLagInput:
      return 4;
      break;
    case SCHEME_HessLagOutput:
      return 5;
      break;
    case SCHEME_NlpSolverInput:
      return 8;
      break;
    case SCHEME_NlpSolverOutput:
      return 6;
      break;
    case SCHEME_QcqpSolverInput:
      return 12;
      break;
    case SCHEME_QcqpSolverOutput:
      return 4;
      break;
    case SCHEME_QCQPStruct:
      return 3;
      break;
    case SCHEME_QpSolverInput:
      return 9;
      break;
    case SCHEME_QpSolverOutput:
      return 4;
      break;
    case SCHEME_QPStruct:
      return 2;
      break;
    case SCHEME_SDPInput:
      return 8;
      break;
    case SCHEME_SDPOutput:
      return 7;
      break;
    case SCHEME_SDPStruct:
      return 3;
      break;
    case SCHEME_SDQPInput:
      return 9;
      break;
    case SCHEME_SDQPOutput:
      return 7;
      break;
    case SCHEME_SDQPStruct:
      return 4;
      break;
    case SCHEME_SOCPInput:
      return 10;
      break;
    case SCHEME_SOCPOutput:
      return 4;
      break;
    case SCHEME_SOCPStruct:
      return 2;
      break;
    case SCHEME_StabilizedQpSolverInput:
      return 12;
      break;
  default: casadi_error("getSchemeSize: Scheme '" << scheme <<  "' does not exist.");
  }
}
int getSchemeEntryEnum(InputOutputScheme scheme, const std::string &name) {
  switch (scheme) {
    case SCHEME_CLEInput:
      if (name=="a") return 0;
      if (name=="v") return 1;
      break;
    case SCHEME_CLEOutput:
      if (name=="p") return 0;
      break;
    case SCHEME_CleStruct:
      if (name=="a") return 0;
      if (name=="v") return 1;
      if (name=="c") return 2;
      break;
    case SCHEME_ControlledDAEInput:
      if (name=="t") return 0;
      if (name=="x") return 1;
      if (name=="z") return 2;
      if (name=="p") return 3;
      if (name=="u") return 4;
      if (name=="u_interp") return 5;
      if (name=="x_major") return 6;
      if (name=="t0") return 7;
      if (name=="tf") return 8;
      break;
    case SCHEME_ControlSimulatorInput:
      if (name=="x0") return 0;
      if (name=="p") return 1;
      if (name=="u") return 2;
      break;
    case SCHEME_DLEInput:
      if (name=="a") return 0;
      if (name=="v") return 1;
      break;
    case SCHEME_DLEOutput:
      if (name=="p") return 0;
      break;
    case SCHEME_DleStruct:
      if (name=="a") return 0;
      if (name=="v") return 1;
      break;
    case SCHEME_DPLEInput:
      if (name=="a") return 0;
      if (name=="v") return 1;
      break;
    case SCHEME_DPLEOutput:
      if (name=="p") return 0;
      break;
    case SCHEME_DpleVecStruct:
      if (name=="a") return 0;
      if (name=="v") return 1;
      break;
    case SCHEME_HNLPInput:
      if (name=="x") return 0;
      if (name=="p") return 1;
      if (name=="tau") return 2;
      break;
    case SCHEME_DAEInput:
      if (name=="x") return 0;
      if (name=="z") return 1;
      if (name=="p") return 2;
      if (name=="t") return 3;
      break;
    case SCHEME_DAEOutput:
      if (name=="ode") return 0;
      if (name=="alg") return 1;
      if (name=="quad") return 2;
      break;
    case SCHEME_RDAEInput:
      if (name=="rx") return 0;
      if (name=="rz") return 1;
      if (name=="rp") return 2;
      if (name=="x") return 3;
      if (name=="z") return 4;
      if (name=="p") return 5;
      if (name=="t") return 6;
      break;
    case SCHEME_RDAEOutput:
      if (name=="ode") return 0;
      if (name=="alg") return 1;
      if (name=="quad") return 2;
      break;
    case SCHEME_IntegratorInput:
      if (name=="x0") return 0;
      if (name=="p") return 1;
      if (name=="z0") return 2;
      if (name=="rx0") return 3;
      if (name=="rp") return 4;
      if (name=="rz0") return 5;
      break;
    case SCHEME_IntegratorOutput:
      if (name=="xf") return 0;
      if (name=="qf") return 1;
      if (name=="zf") return 2;
      if (name=="rxf") return 3;
      if (name=="rqf") return 4;
      if (name=="rzf") return 5;
      break;
    case SCHEME_LinsolInput:
      if (name=="A") return 0;
      if (name=="B") return 1;
      break;
    case SCHEME_LinsolOutput:
      if (name=="X") return 0;
      break;
    case SCHEME_LpSolverInput:
      if (name=="c") return 0;
      if (name=="a") return 1;
      if (name=="lba") return 2;
      if (name=="uba") return 3;
      if (name=="lbx") return 4;
      if (name=="ubx") return 5;
      break;
    case SCHEME_LpSolverOutput:
      if (name=="x") return 0;
      if (name=="cost") return 1;
      if (name=="lam_a") return 2;
      if (name=="lam_x") return 3;
      break;
    case SCHEME_LPStruct:
      if (name=="a") return 0;
      break;
    case SCHEME_LR_DLEInput:
      if (name=="a") return 0;
      if (name=="v") return 1;
      if (name=="c") return 2;
      if (name=="h") return 3;
      break;
    case SCHEME_LR_DLEOutput:
      if (name=="y") return 0;
      break;
    case SCHEME_LrDleStruct:
      if (name=="a") return 0;
      if (name=="v") return 1;
      if (name=="c") return 2;
      if (name=="h") return 3;
      break;
    case SCHEME_LR_DPLEInput:
      if (name=="a") return 0;
      if (name=="v") return 1;
      if (name=="c") return 2;
      if (name=="h") return 3;
      break;
    case SCHEME_LR_DPLEOutput:
      if (name=="y") return 0;
      break;
    case SCHEME_LrDpleVecStruct:
      if (name=="a") return 0;
      if (name=="v") return 1;
      if (name=="c") return 2;
      if (name=="h") return 3;
      break;
    case SCHEME_NLPInput:
      if (name=="x") return 0;
      if (name=="p") return 1;
      break;
    case SCHEME_NLPOutput:
      if (name=="f") return 0;
      if (name=="g") return 1;
      break;
    case SCHEME_GradFInput:
      if (name=="x") return 0;
      if (name=="p") return 1;
      break;
    case SCHEME_GradFOutput:
      if (name=="grad") return 0;
      if (name=="f") return 1;
      if (name=="g") return 2;
      break;
    case SCHEME_JacGInput:
      if (name=="x") return 0;
      if (name=="p") return 1;
      break;
    case SCHEME_JacGOutput:
      if (name=="jac") return 0;
      if (name=="f") return 1;
      if (name=="g") return 2;
      break;
    case SCHEME_HessLagInput:
      if (name=="x") return 0;
      if (name=="p") return 1;
      if (name=="lam_f") return 2;
      if (name=="lam_g") return 3;
      break;
    case SCHEME_HessLagOutput:
      if (name=="hess") return 0;
      if (name=="f") return 1;
      if (name=="g") return 2;
      if (name=="grad_x") return 3;
      if (name=="grad_p") return 4;
      break;
    case SCHEME_NlpSolverInput:
      if (name=="x0") return 0;
      if (name=="p") return 1;
      if (name=="lbx") return 2;
      if (name=="ubx") return 3;
      if (name=="lbg") return 4;
      if (name=="ubg") return 5;
      if (name=="lam_x0") return 6;
      if (name=="lam_g0") return 7;
      break;
    case SCHEME_NlpSolverOutput:
      if (name=="x") return 0;
      if (name=="f") return 1;
      if (name=="g") return 2;
      if (name=="lam_x") return 3;
      if (name=="lam_g") return 4;
      if (name=="lam_p") return 5;
      break;
    case SCHEME_QcqpSolverInput:
      if (name=="h") return 0;
      if (name=="g") return 1;
      if (name=="p") return 2;
      if (name=="q") return 3;
      if (name=="r") return 4;
      if (name=="a") return 5;
      if (name=="lba") return 6;
      if (name=="uba") return 7;
      if (name=="lbx") return 8;
      if (name=="ubx") return 9;
      if (name=="x0") return 10;
      if (name=="lam_x0") return 11;
      break;
    case SCHEME_QcqpSolverOutput:
      if (name=="x") return 0;
      if (name=="cost") return 1;
      if (name=="lam_a") return 2;
      if (name=="lam_x") return 3;
      break;
    case SCHEME_QCQPStruct:
      if (name=="h") return 0;
      if (name=="p") return 1;
      if (name=="a") return 2;
      break;
    case SCHEME_QpSolverInput:
      if (name=="h") return 0;
      if (name=="g") return 1;
      if (name=="a") return 2;
      if (name=="lba") return 3;
      if (name=="uba") return 4;
      if (name=="lbx") return 5;
      if (name=="ubx") return 6;
      if (name=="x0") return 7;
      if (name=="lam_x0") return 8;
      break;
    case SCHEME_QpSolverOutput:
      if (name=="x") return 0;
      if (name=="cost") return 1;
      if (name=="lam_a") return 2;
      if (name=="lam_x") return 3;
      break;
    case SCHEME_QPStruct:
      if (name=="h") return 0;
      if (name=="a") return 1;
      break;
    case SCHEME_SDPInput:
      if (name=="f") return 0;
      if (name=="c") return 1;
      if (name=="g") return 2;
      if (name=="a") return 3;
      if (name=="lba") return 4;
      if (name=="uba") return 5;
      if (name=="lbx") return 6;
      if (name=="ubx") return 7;
      break;
    case SCHEME_SDPOutput:
      if (name=="x") return 0;
      if (name=="p") return 1;
      if (name=="dual") return 2;
      if (name=="cost") return 3;
      if (name=="dual_cost") return 4;
      if (name=="lam_a") return 5;
      if (name=="lam_x") return 6;
      break;
    case SCHEME_SDPStruct:
      if (name=="f") return 0;
      if (name=="g") return 1;
      if (name=="a") return 2;
      break;
    case SCHEME_SDQPInput:
      if (name=="h") return 0;
      if (name=="c") return 1;
      if (name=="f") return 2;
      if (name=="g") return 3;
      if (name=="a") return 4;
      if (name=="lba") return 5;
      if (name=="uba") return 6;
      if (name=="lbx") return 7;
      if (name=="ubx") return 8;
      break;
    case SCHEME_SDQPOutput:
      if (name=="x") return 0;
      if (name=="p") return 1;
      if (name=="dual") return 2;
      if (name=="cost") return 3;
      if (name=="dual_cost") return 4;
      if (name=="lam_a") return 5;
      if (name=="lam_x") return 6;
      break;
    case SCHEME_SDQPStruct:
      if (name=="h") return 0;
      if (name=="f") return 1;
      if (name=="g") return 2;
      if (name=="a") return 3;
      break;
    case SCHEME_SOCPInput:
      if (name=="g") return 0;
      if (name=="h") return 1;
      if (name=="e") return 2;
      if (name=="f") return 3;
      if (name=="c") return 4;
      if (name=="a") return 5;
      if (name=="lba") return 6;
      if (name=="uba") return 7;
      if (name=="lbx") return 8;
      if (name=="ubx") return 9;
      break;
    case SCHEME_SOCPOutput:
      if (name=="x") return 0;
      if (name=="cost") return 1;
      if (name=="lam_a") return 2;
      if (name=="lam_x") return 3;
      break;
    case SCHEME_SOCPStruct:
      if (name=="g") return 0;
      if (name=="a") return 1;
      break;
    case SCHEME_StabilizedQpSolverInput:
      if (name=="h") return 0;
      if (name=="g") return 1;
      if (name=="a") return 2;
      if (name=="lba") return 3;
      if (name=="uba") return 4;
      if (name=="lbx") return 5;
      if (name=="ubx") return 6;
      if (name=="x0") return 7;
      if (name=="lam_x0") return 8;
      if (name=="muR") return 9;
      if (name=="muE") return 10;
      if (name=="mu") return 11;
      break;
  }
  casadi_error("getSchemeEntryEnum: Scheme '" << getSchemeName(scheme)
               <<  "' has no entry named '" << name
               <<  "'. Available entries are: "
                << getSchemeEntryNames(scheme) << ".");
}
} // namespace casadi

